1. So why can't we click these items when using the `SortPipe`?  
   **ê·¸ë ‡ë‹¤ë©´ ì™œ `SortPipe`ë¥¼ ì‚¬ìš©í•  ë•Œ ì´ í•­ëª©ë“¤ì„ í´ë¦­í•  ìˆ˜ ì—†ì„ê¹Œìš”?**

2. Well, we can click them, I can tell you that,  
   `onReset` is getting triggered and the code in there will execute,  
   but Angular will not update this part of the UI,  
   it will not re-execute this `SortPipe`  
   on the updated `historicTemperatures` array,  
   and therefore we still see the old list.  
   **ì‚¬ì‹¤ í´ë¦­ì€ ê°€ëŠ¥í•©ë‹ˆë‹¤.  
   `onReset`ì´ íŠ¸ë¦¬ê±°ë˜ë©° í•´ë‹¹ ì½”ë“œê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.  
   ê·¸ëŸ¬ë‚˜ AngularëŠ” ì´ UI ë¶€ë¶„ì„ ì—…ë°ì´íŠ¸í•˜ì§€ ì•Šê³ ,  
   ì—…ë°ì´íŠ¸ëœ `historicTemperatures` ë°°ì—´ì— ëŒ€í•´  
   `SortPipe`ë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—  
   ì—¬ì „íˆ ì´ì „ ë¦¬ìŠ¤íŠ¸ê°€ ë³´ì…ë‹ˆë‹¤.**

3. So Angular is reusing the old result  
   of this `SortPipe` transform method.  
   **ì¦‰, AngularëŠ” `SortPipe`ì˜ `transform` ë©”ì„œë“œì˜  
   ì´ì „ ê²°ê³¼ë¥¼ ì¬ì‚¬ìš©í•˜ê³  ìˆìŠµë‹ˆë‹¤.**

4. And this is no bug, but instead an intended feature,  
   because the idea is that those pipe transform methods  
   can potentially be executed quite a lot.  
   **ì´ëŠ” ë²„ê·¸ê°€ ì•„ë‹ˆë¼ ì˜ë„ëœ ê¸°ëŠ¥ì…ë‹ˆë‹¤.  
   íŒŒì´í”„ì˜ `transform` ë©”ì„œë“œëŠ”  
   ìì£¼ ì‹¤í–‰ë  ê°€ëŠ¥ì„±ì´ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.**

5. After all, you are using them in your templates,  
   and therefore, whenever the template is rendered again,  
   because anything changed anywhere in a component,  
   all those pipe transform methods would be triggered again.  
   **ê²°êµ­, í…œí”Œë¦¿ì—ì„œ íŒŒì´í”„ë¥¼ ì‚¬ìš©í•˜ê³  ìˆìœ¼ë¯€ë¡œ,  
   ì»´í¬ë„ŒíŠ¸ì˜ ì–´ëŠ ë¶€ë¶„ì—ì„œë“  ë³€ê²½ì´ ë°œìƒí•  ë•Œë§ˆë‹¤  
   í…œí”Œë¦¿ì´ ë‹¤ì‹œ ë Œë”ë§ë˜ë©° ëª¨ë“  íŒŒì´í”„ì˜  
   `transform` ë©”ì„œë“œê°€ ë‹¤ì‹œ ì‹¤í–‰ë  ê²ƒì…ë‹ˆë‹¤.**

6. So those `transform` methods can potentially run a lot.  
   **ë”°ë¼ì„œ `transform` ë©”ì„œë“œëŠ” ìì£¼ ì‹¤í–‰ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.**

7. And by default, Angular prevents that  
   by caching the return value and by only rerunning `transform`  
   if the input value changed.  
   **AngularëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë°˜í™˜ ê°’ì„ ìºì‹±í•˜ê³ ,  
   ì…ë ¥ ê°’ì´ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ `transform`ì„  
   ë‹¤ì‹œ ì‹¤í–‰í•¨ìœ¼ë¡œì¨ ì´ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.**

---

### JavaScript ë°°ì—´ ë° ì°¸ì¡° ë¬¸ì œ

8. Now, you could say, yeah, but the input value does change  
   if I click one of these numbers,  
   after all, it will be replaced with the number 18.  
   **ì´ë•Œ "í•˜ì§€ë§Œ ì…ë ¥ ê°’ì€ ë³€ê²½ë˜ì§€ ì•Šë‚˜ìš”?  
   ìˆ«ìë¥¼ í´ë¦­í•˜ë©´ ê°’ì´ 18ë¡œ ëŒ€ì²´ë˜ë‹ˆê¹Œìš”"ë¼ê³  ë§í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.**

9. And you would be right,  
   but since we're dealing with an array here  
   and I'm overwriting a value inside of that array,  
   instead of the entire array,  
   Angular will ignore that change.  
   **ë§ëŠ” ë§ì´ì§€ë§Œ, í˜„ì¬ ë°°ì—´ì„ ë‹¤ë£¨ê³  ìˆê³   
   ë°°ì—´ ì „ì²´ê°€ ì•„ë‹Œ ë°°ì—´ ë‚´ë¶€ì˜ ê°’ì„ ë®ì–´ì“°ê³  ìˆê¸° ë•Œë¬¸ì—  
   AngularëŠ” ì´ ë³€ê²½ ì‚¬í•­ì„ ë¬´ì‹œí•©ë‹ˆë‹¤.**

10. Because Angular will check for changes  
    by comparing the new value with the old value.  
    **AngularëŠ” ì´ì „ ê°’ê³¼ ìƒˆ ê°’ì„ ë¹„êµí•˜ì—¬  
    ë³€ê²½ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.**

11. And in JavaScript, arrays and objects when changed internally,  
    as a whole, don't change.  
    **ê·¸ë¦¬ê³  JavaScriptì—ì„œ ë°°ì—´ê³¼ ê°ì²´ëŠ” ë‚´ë¶€ê°€ ë³€ê²½ë˜ì–´ë„  
    ì „ì²´ì ìœ¼ë¡œëŠ” ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.**

12. Arrays and objects in JavaScript are, in the end,  
    reference values,  
    which mean the input value we get  
    is just a pointer to the array or object in memory.  
    **JavaScriptì˜ ë°°ì—´ê³¼ ê°ì²´ëŠ” ê²°êµ­ ì°¸ì¡° ê°’ì…ë‹ˆë‹¤.  
    ì¦‰, ì…ë ¥ ê°’ì€ ë©”ëª¨ë¦¬ì— ìˆëŠ” ë°°ì—´ ë˜ëŠ” ê°ì²´ë¥¼  
    ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ì¼ ë¿ì…ë‹ˆë‹¤.**

13. And attached to this lecture,  
    you'll find a link to an article  
    which explores this concept in greater detail  
    in case it's brand new to you.  
    **ê·¸ë¦¬ê³  ì´ë²ˆ ê°•ì˜ì— ì²¨ë¶€ëœ ë§í¬ì—ì„œ  
    ì´ ê°œë…ì— ëŒ€í•´ ìì„¸íˆ ë‹¤ë£¬ ê¸°ì‚¬ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
    ì´ ë‚´ìš©ì´ ìƒì†Œí•˜ë‹¤ë©´ ì°¸ê³ í•˜ì„¸ìš”.**

14. But in the end, the problem is that those pointers  
    to arrays or objects in memory don't change  
    if a value inside of an array or object changes.  
    **ê²°êµ­ ë¬¸ì œëŠ” ë°°ì—´ ë˜ëŠ” ê°ì²´ ë‚´ë¶€ ê°’ì´ ë³€ê²½ë˜ì–´ë„  
    ë©”ëª¨ë¦¬ì˜ í•´ë‹¹ ë°°ì—´ì´ë‚˜ ê°ì²´ë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ëŠ”  
    ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì…ë‹ˆë‹¤.**

15. So when Angular compares the old to the new value,  
    it just sees the same pointer to the same array in memory.  
    **ë”°ë¼ì„œ Angularê°€ ì´ì „ ê°’ê³¼ ìƒˆ ê°’ì„ ë¹„êµí•  ë•Œ,  
    ë™ì¼í•œ ë°°ì—´ì„ ê°€ë¦¬í‚¤ëŠ” ë™ì¼í•œ í¬ì¸í„°ë¡œë§Œ ì¸ì‹í•©ë‹ˆë‹¤.**

---

### ë°°ì—´ ë³µì‚¬ ë° ì°¸ì¡° ì—…ë°ì´íŠ¸

16. So therefore, to get Angular to run `transform` again,  
    you must update your array in a different way here in `onReset`.  
    **ë”°ë¼ì„œ Angularê°€ `transform`ì„ ë‹¤ì‹œ ì‹¤í–‰í•˜ë„ë¡ í•˜ë ¤ë©´  
    `onReset`ì—ì„œ ë°°ì—´ì„ ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤.**

17. Instead of overriding one value in the array,  
    you need to override the array as a whole.  
    **ë°°ì—´ì˜ ê°’ì„ í•˜ë‚˜ë§Œ ë®ì–´ì“°ëŠ” ëŒ€ì‹   
    ë°°ì—´ ì „ì²´ë¥¼ ë®ì–´ì¨ì•¼ í•©ë‹ˆë‹¤.**

18. Which you could do by copying  
    this `historicTemperatures` into a new array,  
    which we could store in a `newTemps` constant.  
    **ì´ë¥¼ ìœ„í•´ `historicTemperatures` ë°°ì—´ì„ ë³µì‚¬í•´  
    `newTemps` ìƒìˆ˜ì— ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.**

19. And then you would reach out to this `newTemps` array,  
    so to that copy and replace the number there,  
    and then replace this `historicTemperatures`  
    with this new array, so with that copied array.  
    **ê·¸ëŸ° ë‹¤ìŒ `newTemps` ë°°ì—´, ì¦‰ ë³µì‚¬ë³¸ì— ì ‘ê·¼í•´  
    ê°’ì„ êµì²´í•˜ê³ ,  
    ìµœì¢…ì ìœ¼ë¡œ `historicTemperatures`ë¥¼  
    ë³µì‚¬ëœ ìƒˆ ë°°ì—´ë¡œ êµì²´í•˜ë©´ ë©ë‹ˆë‹¤.**

20. With that, you got a brand new array in memory  
    and a brand new reference,  
    and therefore, if you save that,  
    if you reload and you click on one of these items,  
    you will now see it changes.  
    **ì´ë ‡ê²Œ í•˜ë©´ ìƒˆë¡œìš´ ë°°ì—´ê³¼ ìƒˆë¡œìš´ ì°¸ì¡°ê°€ ìƒì„±ë˜ë©°,  
    ì €ì¥ í›„ ë‹¤ì‹œ ë¡œë“œí•˜ê³  í•­ëª©ì„ í´ë¦­í•˜ë©´  
    ê°’ì´ ë³€ê²½ë˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.**

---

### ë™ì‘ í™•ì¸ ë° ë¬¸ì œ í•´ê²°

21. It then is also automatically moved  
    because Angular does re-execute that transform method now  
    and does sort that array again.  
    **ì´ì œ Angularê°€ `transform` ë©”ì„œë“œë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•˜ê³   
    ë°°ì—´ì„ ë‹¤ì‹œ ì •ë ¬í•˜ë¯€ë¡œ ê°’ì´ ìë™ìœ¼ë¡œ ì´ë™ë©ë‹ˆë‹¤.**

22. That's why Angular also automatically moves it.  
    **ê·¸ë˜ì„œ Angularê°€ ì´ë¥¼ ìë™ìœ¼ë¡œ ì´ë™ì‹œí‚¤ëŠ” ê²ƒì…ë‹ˆë‹¤.**

23. Which in turn means that the indexes also get messed up  
    because the indexes in the rendered list  
    are now not in line with the indexes in the input data.  
    **ì´ëŠ” ë Œë”ë§ëœ ë¦¬ìŠ¤íŠ¸ì˜ ì¸ë±ìŠ¤ê°€  
    ì…ë ¥ ë°ì´í„°ì˜ ì¸ë±ìŠ¤ì™€ ì¼ì¹˜í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—  
    ì¸ë±ìŠ¤ê°€ í˜¼ë€ìŠ¤ëŸ¬ì›Œì§ˆ ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.**

24. But that's not too important here  
    because this lecture was about understanding  
    how this behaves here and how you need to update  
    array or object values to get this transform method  
    to run again.  
    **í•˜ì§€ë§Œ ì´ ê°•ì˜ëŠ” ì´ëŸ° ë™ì‘ì„ ì´í•´í•˜ê³   
    `transform` ë©”ì„œë“œë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•˜ê¸° ìœ„í•´  
    ë°°ì—´ì´ë‚˜ ê°ì²´ ê°’ì„ ì–´ë–»ê²Œ ì—…ë°ì´íŠ¸í•´ì•¼ í•˜ëŠ”ì§€ë¥¼  
    ë‹¤ë£¨ëŠ” ê²ƒì´ ëª©ì ì´ë¯€ë¡œ,  
    ì¸ë±ìŠ¤ ë¬¸ì œëŠ” ì—¬ê¸°ì„œ í¬ê²Œ ì¤‘ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.**

25. Though there also is an alternative to that.  
    **ë¬¼ë¡  ì´ë¥¼ ëŒ€ì²´í•  ë°©ë²•ë„ ìˆìŠµë‹ˆë‹¤.**

---

ë²ˆì—­ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì¶”ê°€ ìš”ì²­ì´ ìˆë‹¤ë©´ ë§ì”€í•´ ì£¼ì„¸ìš”! ğŸ˜Š
