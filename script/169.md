### 1
So why can't we click these items  
when using the SortPipe?

ê·¸ë ‡ë‹¤ë©´, ì™œ `SortPipe`ë¥¼ ì‚¬ìš©í•  ë•Œ  
ì´ í•­ëª©ë“¤ì„ í´ë¦­í•  ìˆ˜ ì—†ëŠ” ê±¸ê¹Œìš”?

---

### 2
Well, we can click them, I can tell you that,  
onReset is getting triggered

and the code in there will execute,

but Angular will not update this part of the UI,

it will not re-execute this SortPipe

on the updated historicTemperatures array,

and therefore we still see the old list.

ì‚¬ì‹¤, í´ë¦­ì€ ê°€ëŠ¥í•©ë‹ˆë‹¤.  
`onReset`ì´ íŠ¸ë¦¬ê±°ë˜ë©°,  
ê·¸ ì•ˆì˜ ì½”ë“œë„ ì‹¤í–‰ë©ë‹ˆë‹¤.  
í•˜ì§€ë§Œ AngularëŠ” ì´ UI ë¶€ë¶„ì„  
ì—…ë°ì´íŠ¸í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  
ì¦‰, ë³€ê²½ëœ `historicTemperatures` ë°°ì—´ì— ëŒ€í•´  
`SortPipe`ë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ  
ì—¬ì „íˆ ì´ì „ ë¦¬ìŠ¤íŠ¸ê°€ í‘œì‹œë©ë‹ˆë‹¤.

---

### 3
So Angular is reusing the old result  
of this SortPipe transform method.

AngularëŠ”
SortPipeì˜ transform ë©”ì„œë“œë¥¼ ì ìš©í•˜ê¸° ì „ì˜
ê²°ê³¼ë¥¼ ì¬ì‚¬ìš©í•©ë‹ˆë‹¤.

---

### 4
And this is no bug, but instead an intended feature

because the idea is that those pipe transform methods

can potentially be executed quite a lot.

ê·¸ë¦¬ê³  ì´ê²ƒì€ ë²„ê·¸ê°€ ì•„ë‹ˆë¼,  
ì„¤ê³„ëœ ê¸°ëŠ¥ì…ë‹ˆë‹¤.  
ì™œëƒí•˜ë©´ íŒŒì´í”„ì˜ `transform` ë©”ì„œë“œëŠ”  
ìƒë‹¹íˆ ìì£¼ ì‹¤í–‰ë  ê°€ëŠ¥ì„±ì´ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

---

### 5
After all, you are using them in your templates,

and therefore, whenever the template is rendered again,

because anything changed anywhere in a component,

all those pipe transform methods would be triggered again.

ê²°êµ­, íŒŒì´í”„ëŠ” í…œí”Œë¦¿ì—ì„œ ì‚¬ìš©ë˜ë¯€ë¡œ,  
ì»´í¬ë„ŒíŠ¸ ì–´ë””ì—ì„œë“   
ë¬´ì–¸ê°€ê°€ ë³€ê²½ë˜ì–´ í…œí”Œë¦¿ì´ ë‹¤ì‹œ ë Œë”ë§ë  ë•Œë§ˆë‹¤  
ëª¨ë“  íŒŒì´í”„ì˜ `transform` ë©”ì„œë“œê°€  
ë‹¤ì‹œ ì‹¤í–‰ë˜ê²Œ ë©ë‹ˆë‹¤.

---

### 6
So those transform methods can potentially run a lot.

ë”°ë¼ì„œ `transform` ë©”ì„œë“œëŠ”  
ì•„ì£¼ ìì£¼ ì‹¤í–‰ë  ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤.

---

### 7
And by default, Angular prevents that

by caching the return value and by only rerunning transform

if the input value changed.

AngularëŠ” ê¸°ë³¸ì ìœ¼ë¡œ,  
`transform` ë©”ì„œë“œì˜ ë°˜í™˜ê°’ì„ ìºì‹±í•˜ê³ ,  
ì…ë ¥ê°’ì´ ë³€ê²½ëœ ê²½ìš°ì—ë§Œ  
`transform`ì„ ë‹¤ì‹œ ì‹¤í–‰í•¨ìœ¼ë¡œì¨ ì´ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.

---

### 8
Now, you could say, yeah, but the input value does change

if I click one of these numbers,

after all, it will be replaced with the number 18.

ê·¸ë¦¬ê³  "í•˜ì§€ë§Œ ì…ë ¥ê°’ì€  
ë‚´ê°€ ìˆ«ì ì¤‘ í•˜ë‚˜ë¥¼ í´ë¦­í•˜ë©´ ë³€ê²½ë˜ëŠ”ë°ìš”?"  
ë¼ê³  ìƒê°í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.  
ì™œëƒí•˜ë©´ ê°’ì´ 18ë¡œ ëŒ€ì²´ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

---

### 9
And you would be right,

but since we're dealing with an array here

and I'm overwriting a value inside of that array,

instead of the entire array,

Angular will ignore that change.

ë§ìŠµë‹ˆë‹¤.  
í•˜ì§€ë§Œ ì§€ê¸ˆ ìš°ë¦¬ëŠ” ë°°ì—´ì„ ì²˜ë¦¬í•˜ê³  ìˆê³ ,  
ë°°ì—´ ì „ì²´ë¥¼ ëŒ€ì²´í•˜ëŠ” ëŒ€ì‹   
ë°°ì—´ ë‚´ë¶€ì˜ ê°’ì„ ë®ì–´ì“°ê³  ìˆê¸° ë•Œë¬¸ì—  
AngularëŠ” ì´ ë³€ê²½ì„ ë¬´ì‹œí•©ë‹ˆë‹¤.

---

### 10
Because Angular will check for changes

by comparing the new value with the old value.

ì™œëƒí•˜ë©´ AngularëŠ”  
ìƒˆë¡œìš´ ê°’ê³¼ ì´ì „ ê°’ì„ ë¹„êµí•˜ì—¬  
ë³€ê²½ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

---

### 11
And in JavaScript,

arrays and objects when changed internally,

as a whole, don't change.

ê·¸ë¦¬ê³  JavaScriptì—ì„œëŠ”  
ë°°ì—´ì´ë‚˜ ê°ì²´ ë‚´ë¶€ê°€ ë³€ê²½ë˜ë”ë¼ë„,  
ì „ì²´ì ìœ¼ë¡œëŠ” ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

---

### 12
Arrays and objects in JavaScript are in the end

reference values,

which mean the input value we get is just a pointer

to the array or object in memory.

JavaScriptì—ì„œ ë°°ì—´ê³¼ ê°ì²´ëŠ”  
ì°¸ì¡° ê°’ì´ë¯€ë¡œ,  
ì…ë ¥ê°’ì€ ë©”ëª¨ë¦¬ì— ìˆëŠ”  
ë°°ì—´ì´ë‚˜ ê°ì²´ë¥¼ ê°€ë¦¬í‚¤ëŠ”  
í¬ì¸í„°ì¼ ë¿ì…ë‹ˆë‹¤.

---

### 13
And attached to this lecture,

you'll find a link to an article

which explores this concept in greater detail

in case it's brand new to you.

ê·¸ë¦¬ê³  ì´ ê°•ì˜ì— ì²¨ë¶€ëœ  
ê¸°ì‚¬ ë§í¬ë¥¼ í†µí•´  
ì´ ê°œë…ì„ ë” ìì„¸íˆ  
ì‚´í´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### 14
But in the end, the problem is that those pointers

to arrays or objects in memory

don't change if a value

inside of an array or object changes.

ê²°êµ­, ë¬¸ì œëŠ” ë°°ì—´ì´ë‚˜ ê°ì²´ ë‚´ë¶€ì˜ ê°’ì´ ë³€ê²½ë˜ì–´ë„  
ë©”ëª¨ë¦¬ì— ìˆëŠ” ë°°ì—´ì´ë‚˜ ê°ì²´ë¥¼ ê°€ë¦¬í‚¤ëŠ”  
í¬ì¸í„°ëŠ” ë³€ê²½ë˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì…ë‹ˆë‹¤.

---

### 15
So when Angular compares the old to the new value,

it just sees the same pointer to the same array in memory.

ê·¸ë˜ì„œ Angularê°€  
ì´ì „ ê°’ê³¼ ìƒˆë¡œìš´ ê°’ì„ ë¹„êµí•  ë•Œ,  
ì—¬ì „íˆ ê°™ì€ ë°°ì—´ì„ ê°€ë¦¬í‚¤ëŠ”  
ë™ì¼í•œ í¬ì¸í„°ë§Œ ë³´ê²Œ ë©ë‹ˆë‹¤.

---

### 16
So therefore, to get Angular to run transform again,

you must update your array in a different way

here in onReset.

ë”°ë¼ì„œ Angularê°€  
`transform`ì„ ë‹¤ì‹œ ì‹¤í–‰í•˜ë„ë¡ í•˜ë ¤ë©´,  
`onReset`ì—ì„œ ë°°ì—´ì„  
ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤.

### 17
Instead of overriding one value in the array,

you need to override the array as a whole,

which you could do by copying

this historicTemperatures into a new array,

which we could store in a newTemps constant.

ë°°ì—´ì˜ ê°’ì„ í•˜ë‚˜ë§Œ ë®ì–´ì“°ëŠ” ëŒ€ì‹ ,  
ë°°ì—´ ì „ì²´ë¥¼ ë®ì–´ì¨ì•¼ í•©ë‹ˆë‹¤.  
ì´ë¥¼ ìœ„í•´ `historicTemperatures` ë°°ì—´ì„  
ìƒˆ ë°°ì—´ë¡œ ë³µì‚¬í•˜ì—¬,  
ì´ë¥¼ `newTemps`ë¼ëŠ” ìƒìˆ˜ì— ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### 18
And then you would reach out to this newTemps array,

so to that copy and replace the number there,

and then replace this historicTemperatures

with this new array, so with that copied array.

ê·¸ëŸ° ë‹¤ìŒ,  
`newTemps` ë°°ì—´(ì¦‰, ë³µì‚¬ë³¸)ì„ ìˆ˜ì •í•´  
ê·¸ ì•ˆì˜ ìˆ«ìë¥¼ ëŒ€ì²´í•˜ê³ ,  
`historicTemperatures` ë°°ì—´ì„  
ì´ ìƒˆë¡œìš´ ë°°ì—´(ë³µì‚¬ë³¸)ë¡œ êµì²´í•˜ë©´ ë©ë‹ˆë‹¤.

---

### 19
With that, you got a brand new array in memory

and a brand new reference,

and therefore, if you save that,

if you reload and you click on one of these items,

you will now see it changes.

ì´ë ‡ê²Œ í•˜ë©´ ë©”ëª¨ë¦¬ì—ì„œ  
ìƒˆë¡œìš´ ë°°ì—´ê³¼ ìƒˆë¡œìš´ ì°¸ì¡°ë¥¼ ìƒì„±í•˜ê²Œ ë©ë‹ˆë‹¤.  
ê·¸ë¦¬ê³  ì €ì¥í•˜ê³  í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ë¡œë“œí•œ ë’¤,  
í•­ëª© ì¤‘ í•˜ë‚˜ë¥¼ í´ë¦­í•˜ë©´  
ê°’ì´ ë³€ê²½ë˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### 20
It then is also automatically moved

because Angular does re-execute that transform method now

and does sort that array again,

that's why Angular also automatically moves it.

ê·¸ë¦¬ê³  ê°’ì´ ìë™ìœ¼ë¡œ ì •ë ¬ë©ë‹ˆë‹¤.  
ì™œëƒí•˜ë©´ Angularê°€ ì´ì œ  
`transform` ë©”ì„œë“œë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•˜ê³ ,  
ë°°ì—´ì„ ë‹¤ì‹œ ì •ë ¬í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.  
ì´ë¡œ ì¸í•´ Angularê°€ ê°’ì„  
ìë™ìœ¼ë¡œ ì´ë™ì‹œí‚µë‹ˆë‹¤.

---

### 21
Which in turn means that the indexes also get messed up

because the indexes in the rendered list

are now not in line with the indexes in the input data.

í•˜ì§€ë§Œ ì´ë¡œ ì¸í•´ ì¸ë±ìŠ¤ë„  
ì–´ê¸‹ë‚˜ê²Œ ë©ë‹ˆë‹¤.  
ë Œë”ë§ëœ ë¦¬ìŠ¤íŠ¸ì˜ ì¸ë±ìŠ¤ê°€  
ì…ë ¥ ë°ì´í„°ì˜ ì¸ë±ìŠ¤ì™€ ì¼ì¹˜í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

---

### 22
But that's not too important here

because this lecture was about understanding

how this behaves here and how you need to update

array or object values to get this transform method

to run again.

í•˜ì§€ë§Œ ì´ê²ƒì€ ì—¬ê¸°ì„œ  
ë„ˆë¬´ ì¤‘ìš”í•œ ë¬¸ì œê°€ ì•„ë‹™ë‹ˆë‹¤.  
ì´ ê°•ì˜ì˜ í•µì‹¬ì€,  
ì´ ë™ì‘ì„ ì´í•´í•˜ê³ ,  
`transform` ë©”ì„œë“œë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•˜ë„ë¡  
ë°°ì—´ì´ë‚˜ ê°ì²´ ê°’ì„ ì—…ë°ì´íŠ¸í•˜ëŠ”  
ë°©ë²•ì„ ë°°ìš°ëŠ” ê²ƒì…ë‹ˆë‹¤.

---

### 23
Though there also is an alternative to that.

ë¬¼ë¡ , ì´ë¥¼ ìœ„í•œ  
ëŒ€ì²´ ë°©ë²•ë„ ì¡´ì¬í•©ë‹ˆë‹¤.

---

### **ë²ˆì—­ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!** ğŸ˜Š
